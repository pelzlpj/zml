
ZML DESIGN NOTES
----------------

The Z-Machine kind of sucks for this sort of application.  So this may
prove to be a challenge.

A ZML runtime will be implemented in assembly.  This shall offer
facilities for allocating type-tagged memory blocks off the heap.
Allocation looks something like this:

   1) Traverse the "free list" and find the first free chunk big enough
      for our block.

      If successful, remove that chunk from the free list, set up the
      chunk with type tag information, and initialize its value.

      A pointer to the new heap-allocated value is stored in a lookup
      table at the end of RAM.  This lookup table is used by functions
      which need to refer to the block; it gives us a way to relocate
      blocks without modifying the stack, and it serves as a list of
      roots for the GC.

   2) If memory cannot be allocated, use a mark-and-sweep algorithm
      to locate unused blocks.  A new free list is formed from the
      unused blocks.

   3) If memory still cannot be allocated, use a Haddon-Waite
      table-based compaction algorithm to relocate live blocks to the
      beginning of the heap.  The lookup table at the end of RAM also
      has its pointers updated, so that any references on the stack
      remain valid.

      The Haddon-Waite approach is good from the perspective of
      conserving memory; the minimum block size would be two words, and
      there would be zero memory overhead during the compaction.

Use of the ZML runtime requires the following discipline for stack
usage:

   A) When a function needs to (1) perform an operation which may
      allocate memory and then (2) dereference a heap-allocated block,
      then the heap-allocated block must be referred to via the block
      lookup table.
   
   B) When a function allocates a block which it needs to refer to via
      the block lookup table, then the function must explicitly free
      the lookup table reference when it becomes unreachable (as the
      function returns, if not before--unless the block is returned
      to the caller, in which case a reference is live).

In general, when calling a function using a heap-allocated block as an
argument, it will be the lookup table pointer which is passed as the
argument to 'call'.  An exception could be when static analysis
indicates that both that function and all recursively-called functions
do not allocate memory.

Mark-and-Sweep:

   1) For each pointer in the global roots table, recursively mark the
      pointed-to block.  "Recursively mark" means marking the block
      and all unmarked blocks it points to, in recursive fashion.

   2) Traverse all memory blocks in the heap.  (The blocks are
      structured such that we can iterate through them efficiently.)
      If the block is marked, then clear the mark.  If the block is
      unmarked, then clear the mark and add the block to the
      (newly-created) free list.  Adjacent free list cells are
      coalesced to assist in allocating larger blocks.

Value Representation:

   * All blocks shall be aligned on a two-word boundary, and shall have a
     two-word-aligned length.  This ensures that (1) every free area is
     large enough to store two words and (2) the word count of a
     memory block will fit in 15 bits.  This permits the following
     representation of a freelist cons cell:

                        +----------+
               Word 1:  |1|   N    |
               Word 2:  | next_ptr |
                ...     |  (free)  |
               Word N:  |   ...    |
                        +----------+
     
     The '1' in Word 1 uniquely identifies a free list cell.  We have 15
     bits available for N, which implies that the entirety of RAM can be
     expressed as a single free region.

   * Blocks containing values shall begin with a header word:

                        ------------
               Word 1:  |0|M|Tag|  |
                        ------------

     The first bit is 0, to indicate that this is a value and not a free
     block.  The second bit is the Mark bit used by the mark/sweep
     algorithm.  The Tag is a four bit value used to differentiate all the
     supported block types.  The remaining 10 bits are reserved for type-
     specific data.

   * Tag 0 is used for a "value array cell", i.e. a heap-allocated block
     which contains a sequence of words which are not pointers.  To
     conserve space, the array cell has two possible representations.
     When the array size is in the range [0, 2^10-2], then the array
     is expressed as follows:

                        +-------------+
               Word 1:  |0|M| 0|  N-1 |
               Word 2:  | (value 0)   |
               Word 3:  | (value 1)   |
                ...     |   ...       |
               Word N:  | (value N-2) |
                        |   padding   |
                        +-------------+
     
     In other words, the size of the array is packed into the reserved
     space in the header.  When the size of the array exceeds 2^10-2,
     then the array has an additional word reserved for its size:

                        +-------------+
               Word 1:  |0|M| 0|2^10-1|
               Word 2:  |   N - 2     |
               Word 3:  | (value 0)   |
               Word 3:  | (value 1)   |
                ...     |   ...       |
               Word N:  | (value N-3) |
                        |   padding   |
                        +-------------+

     In either case, the storage size of the array may be padded by a
     single word as necessary to satisfy the two-word-aligned
     length requirement.

   * Tag 1 is used for a "reference array cell", i.e. a heap-allocated
     block which contains pointers to other blocks.  The layout is otherwise
     identical to the value array cell.  (Note that the reference array
     cell also serves as storage for ML record types.)

   * Tag 2 is used for a "value list cell", i.e. a heap-allocated block
     which contains both a value and a pointer to another value list cell.
     To satisfy alignment, a padding word is appended; its content is
     undefined.

                        +-------------+
               Word 1:  |0|M| 2|      |
               Word 2:  |   (value)   |
               Word 3:  | (next ptr)  |
               Word 4:  |   padding   |
                        +-------------+
     
     A list cell need not point to another cell (end of list condition).
     In this case, Word 3 shall have value 0xffff.

     Note: with some care, it might be possible to fit a list cell in two
     words.  The "next cell" pointer can be represented in 14 bits at
     most...

   * Tag 3 is used for a "reference list cell", i.e. a heap-allocated
     block which contains both a pointer to an arbitrary item and a
     pointer to another value list cell.  The layout is otherwise identical
     to the value list cell.

Roots Table:

   The table of roots needs to efficiently support the following
   operations:

      1) root_reference = register_root(heap_reference)
         
         Generate a new root identifier for a heap reference, and store
         the heap reference in a location where the GC can track it.

      2) heap_reference = lookup_root(root_reference)

         Given a root identifier for a heap reference, get the current
         value of the heap reference.  This is required because heap
         references will get relocated by the compaction algorithm.

      3) unregister_root(root_reference)

         Remove a root identifier from the set of GC roots.

   These goals can be accomplished using an array of heap references at
   the end of RAM; the physical address of a table entry serves as the
   "root reference".  Each (word-sized) element of the array is either
   occupied by a heap reference, or is a freelist element.  The freelist
   carries no data; each node is simply a word pointer to the next
   freelist node.

   The roots table can easily be made to grow dynamically.  Initially it
   has size 0.  When register_root() is invoked and the freelist is
   empty, then the table extends one position to the "left" (decreasing
   memory address).  The heap extends to the "right", so the heap and
   the roots will grow towards each other as memory is exhausted.

   Potentially the roots table could be made to shrink dynamically, as
   roots are dropped.  I suspect that this is not a high-value feature.
   It is significantly more complex to implement than the case of
   dynamically increasing the table size (it basically works out to
   running a filter() operation on the freelist to get rid of all the
   nodes below a certain memory address).

   Note that heap references in the roots table can be easily
   disambiguated from freelist entries, just by examining the pointer
   values.  Freelist entries are pointers to addresses inside the roots
   area, while root entries are pointers to addresses inside the heap
   area.  This property makes it straightforward for the GC to scan the
   roots table when it carries out the "mark" operation.

